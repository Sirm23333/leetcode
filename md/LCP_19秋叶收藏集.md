需要将树叶排除红-黄-红的排列，树叶可以看做有三种状态：
- 树叶的状态为0：这片树叶位于前面的红色部分中
- 树叶的状态为1：这片树叶位于中间的黄色部分中
- 树叶的状态为2：这片树叶位于后面的红色部分中

用一个length×3的矩阵arr代表树叶的状态，arr[i][j]即代表将树叶0-i做调整，使树叶i处于状态j，至少需要的次数

则有以下状态转移函数：
```java
arr[i][0] = arr[i - 1][0] + (leaves.charAt(i) == 'y' ? 1 : 0);
arr[i][1] = Math.min(arr[i-1][0],arr[i-1][1]) + (leaves.charAt(i) == 'r' ? 1 : 0);
arr[i][2] = Math.min(arr[i-1][1],arr[i-1][2]) + (leaves.charAt(i) == 'y' ? 1 : 0);
```
arr[length-1][2]即最后的答案

进一步节省空间：
可以看出，状态2只与前一片树叶的状态1,2有关，状态1只与前一片树叶的状态0，1有关，状态0只有前一片树叶的状态0有关，所以可以将二维数组转为1为数组表示状态，详见代码的第三个版本